// grammar.lark

// common tokens
%import common.NEWLINE
%import common.WS_INLINE
%ignore WS_INLINE

// Start Rule
start: syntax function_def+

// Language and case parameters
syntax: "Language" LANG NEWLINE "Case" CASE NEWLINE

// Function definition
function_def: "fn" type ID "(" [params] ")" block

// Block definition
block: "{" NEWLINE? stmt+ (NEWLINE stmt+)* NEWLINE? "}"

// Statements
?stmt: assignment_stmt ";"
     | declaration
     | if_stmt
     | while_stmt
     | return_stmt ";"
     | output_stmt ";"
     | input_stmt ";"
     | expr_stmt ";"

// Assignment
assignment_stmt: ID "=" expr_logical

// New keyword
declaration: "new" type ID ";"
           | "new" type ID "=" expr_logical ";"
           | "new" type ID "[" expr_logical "]" ";"

// If statement (bruger then keyword lige nu)
if_stmt: "if" expr_logical "then" block "else" block

// While statement
while_stmt: "while" expr_logical "do" block

// Return statement
return_stmt: "return" expr_logical

// Output statement
output_stmt: "output" expr_logical

// Input statement
input_stmt: "input"

// Expression statement
expr_stmt: expr_logical

// Expressions
?expr_logical: expr_not (("and" | "or") expr_not)*
?expr_not: "!" expr_comparison           -> not_expr
         | expr_comparison
?expr_comparison: expr_plus (("<" | ">" | "==") expr_plus)?
?expr_plus: expr_mult (("+" | "-") expr_mult)*
?expr_mult: expr_negative (("*" | "/" | "%") expr_negative)*
?expr_negative: "-" expr_func             -> neg
              | expr_func
?expr_func: ID "(" [arglist] ")"          -> func_call
          | expr_array
?expr_array: expr_term
           | ID "[" expr_term "]"         -> array_access
?expr_term: ID
          | INT
          | DOUBLE
          | BOOL
          | STRING
          | "(" expr_logical ")"

// Function call arguments.
arglist: expr_not ("," expr_not)*

// Parameters in function definitions
params: type ID ("," type ID)*

// Types
type: "boolean" | "integer" | "decimal" | "string" | "noType"

// Keywords for language and case style
LANG: "DK" | "EN"
CASE: "camelCase" | "snake_case"

// Literals
BOOL: "true" | "false"
ID: /[a-z][a-zA-Z0-9]*(?:_[a-z][a-zA-Z0-9]*)*/
INT: /[0-9]+/
DOUBLE: /[0-9]+\.[0-9]+/
STRING: /"([^"\\]*(\\.[^"\\]*)*)"/

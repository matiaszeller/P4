// grammar.lark

// common tokens
%import common.NEWLINE
%import common.WS_INLINE
%ignore WS_INLINE

// Start Rule
start: expr_logical


// Expressions
?expr_logical: expr_not (("and" | "or") expr_not)*
?expr_not: "!" expr_comparison           -> not_expr
         | expr_comparison
?expr_comparison: expr_plus (("<" | ">" | "==") expr_plus)?
?expr_plus: expr_mult ((PLUS | MINUS) expr_mult)*
PLUS: "+"
MINUS: "-"
?expr_mult: expr_negative (("*" | "/" | "%") expr_negative)*
?expr_negative: "-" expr_func             -> neg
              | expr_func
?expr_func: ID "(" [arglist] ")"          -> func_call
          | expr_array
?expr_array: expr_term
           | ID "[" expr_term "]"         -> array_access
?expr_term: ID
          | INT
          | DOUBLE
          | BOOL
          | STRING
          | "(" expr_logical ")"

// Function call arguments.
arglist: expr_not ("," expr_not)*

// Parameters in function definitions
params: type ID ("," type ID)*

// Types
type: "boolean" | "integer" | "decimal" | "string" | "noType"

// Keywords for language and case style
LANG: "DK" | "EN"
CASE: "camelCase" | "snake_case"

// Literals
BOOL: "true" | "false"
ID: /[a-z][a-zA-Z0-9]*(?:_[a-z][a-zA-Z0-9]*)*/
INT: /[0-9]+/
DOUBLE: /[0-9]+\.[0-9]+/
STRING: /"([^"\\]*(\\.[^"\\]*)*)"/
